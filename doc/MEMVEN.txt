.Move Entity

Lbl MVEN {
    .Moves an entity
    .r1: pointer to entity to move
    .r2: dispX
    .r3: dispY
    .r4: layers of indirection from player push
    .T: movement result
    .U: number of movements pushed to stack

    .Storing to stack
    .   A: entity pointer
    .   B: pointer to target entity if applicable
    .   C: entity collision type
    .   D: target x
    .   E: target y
    .   F: target z
    .   S+12: r_2 (dispX)
    .   S+13: r_3 (dispY)
    .   S+14: curr space property byte
    .   S+15: target space property byte
    .   S+16^r: pointer to curr entity pointer
    .   S+18^r: pointer to target entity pointer
    .   S+20: entity interaction
    .   S+21: is target top/bottom of stack
    .   S+22: target z if push-then-move interaction
    .   S+23: r_4 (layers from player push)
    S-24->S
    A->{S}^r
    B->{S+2}^r
    C->{S+4}^r
    D->{S+6}^r
    E->{S+8}^r
    F->{S+10}^r
    r_2->{S+12}
    r_3->{S+13}
    r_4->{S+23}

    .Keeping entity pointer in A
    r_1->A

    .By default, no target pointer
    0->B

    .Finding target position
    {A+1}+r_2->D
    {A+2}+r_3->E

    .Making sure it's in-bounds
    .(due to unsigned comparison, this implicitly makes sure it's non-negative)
    !If D<MW?E<MH
        .If OOB, just cancel this movement
        4->T
        0->U
        Goto MVENE
    End

    .Putting property bytes for current position and target position on stack
    GPBA({A+1},{A+2})->{S+14}
    GPBA(D,E)->{S+15}

    .If we're one layer from the player, and we're on a water raft, defer
    .   movement to the raft, and only proceed if the raft move fails.
    If {S+23}=1?{S+14}e6
        GLEA({A+1},{A+2},0)->G
        If G?G!=A
            GECT({G},{S+12},{S+13})->H
            If H=5
                .Try moving the raft
                MVEN(G,signed{S+12},signed{S+13},{S+23}+1)

                .If the move succeeded, then just abort this movement
                !If T
                    Goto MVENE
                End
            End
        End
    End

    .If we're trying to move into an impenetrable rock, we're blocked
    If {S+15}e4
        0->{S+20}
        Goto MVENA
    End

    .Getting the pointer to our entity
    GEPP({A+3},{A+4})->{S+16}^r

    .Getting our collision type
    GECT({A},{S+12},{S+13})->C

    .Finding the relative height of the target space
    GHAT(D,E)+1->F
    F-{A+5}->G

    If nib{GDB1MEAH*2+C}^r>=>=G
        ??{S+15}e7?nib{GDB1CCLL*2+C}^r
        .Ground is low enough to move to or there's a ladder we can climb

        .Checking for entities on this spot
        If GSEH(D,E)->H
            .Finding the highest entity at/below the player (push target)
            max({A+5},F)->I
            For(J,1,H)
                {-H+J-1*2+S}^r->B
            EndIf {B+5}<=I

            .Determining where our entity is in our stack
            .If bottom of stack, LSB ({S+21}e7) is set
            .If top of stack, 2nd LSB ({S+21}e6) is set
            0->{S+21}
            J=H?{S+21}+1->{S+21}
            J=1?{S+21}+2->{S+21}

            .Getting interaction type between the two entities
            GECT({B},signed{S+12},signed{S+13})->G .(target collision type)
            Select(G,
                GHEB({B+1},{B+2},{B+5})->H
            )->G
            max({A+5},F)->I
            {S+15}e6?H=0
                ->J .(is the target on water)
            {B}->K
            nib{GDB1ENTH*2+K}^r+{B+5}->F .(height just above target)
            {B+5}->{S+22} .(height of target)
            If F>I
                .Above
                nib{C*2+J*4+GDB1EITA*2+G}^r->{S+20}
            Else
                .Below
                nib{C*2+J*4+GDB1EITB*2+G}^r->{S+20}
            End

            .Finally, putting pointer to target on stack before proceeding
            GEPP({B+3},{B+4})->{S+18}^r
        Else
            .If no entities, we can move here
            1->{S+20}
        End
    Else
        .Too high to move to; we've been blocked!
        0->{S+20}
        Goto MVENA
    End

    .In any case, if we are the player, then downgrade certain movement types
    .   if we're trying to walk on water or trying to push from a rolling log
    If {A}=0
        If {S+15}e6?B=0
            6->{S+20}
        ElseIf IMOW({A+1},{A+2},{A+5},{S+12},{S+13})=2
            {S+20}->I
            nib{GDB1PIRD*2+I}^r->{S+20}
        End
    End

    .MVENA (MVEN Action section)
    Lbl MVENA

    0->U (no queued actions by default)

    .Handling pushes in interactions
    If {S+20}=2??{S+20}=3??{S+20}=4
        .Performing push
        MVEN(B,signed{S+12},signed{S+13},{S+23}+1)

        .Restoring pointers to curr/target ent
        MVENRPTR()
    End

    .Handling potential rafting from player pushing
    If {S+23}=0?{S+14}e6        .If it's the player and we're on water
            ?{S+20}!=1?{S+20}<5 .and if it's either a push/block interaction
        .Checking if the bottom entity is a raft
        Select(T,
        Select(U,
            GLEA({A+1},{A+2},0)->G
        )->U
        )->T

        If G
            GECT({G},{S+12},{S+13})->H
            If H=5
                .Let's try to raft!

                .Defer the opposite of our desired movement to the raft
                .(adds two layers of indirection; it's like the we push on the
                .   wall and it pushes back!)
                S->I
                -U*5+S->S
                Select(T,
                Select(U,
                    MVEN(G,-signed{I+12},-signed{I+13},{I+23}+2)
                )->I
                )->J
                I*5+S->S
                U+I->U

                .Restoring pointers to curr/target ent
                MVENRPTR()

                .If the raft moved successfully, then block the rest of
                .   our own movement.
                !If T
                    4->T
                    Goto MVENP
                End

                J->T
            End
        End
    End

    .Handing movements in interactions
    !If {S+20}
        .Blocked
        1->T
    ElseIf {S+20}=1
        .Move if target is top entity or no entity
        If B=0??{S+21}e6
            MVER(A,D,E,F)
            0->T
        Else
            1->T
        End
    ElseIf {S+20}=2
        .Push (but also blocked)
        2->T
    ElseIf {S+20}=3??{S+20}=4
        .Push then move

        .Moving into previously occupied space if available
        !If T
            If {S+21}e7
                .Bottom of stack; just move there
                S->G
                -U*5+S->S
                Select(U,
                    MVER(A,D,E,{G+22})
                )->U
                U*5+S->S
                0->T
            Else
                .Not bottom of stack; defer movement
                MVENPMTQ()
                3->T
            End
        Else
            If T=1?{S+20}=4?{S+21}e6
                .If blocked, push-then-climb, and top ent, move on top!
                -U*5+S->S
                Select(U,
                    MVER(A,D,E,F)
                )->U
                U*5+S->S
                0->T
            End
        End
    ElseIf {S+20}=5
        .Double move
        MVER(A,D,E,F)

        0->U
        MVENPMTQ()
        0->T
    ElseIf {S+20}=6
        .Stop by refusal
        4->T
    ElseIf {S+20}=7
        .Interact (effectively stop by refusal)

        .Currently, only interaction type is snowfolk
        ClrHome
        Output(0,0,"You made a")
        Output(0,1,"friend!")
        PAUS()

        .Marking refusal to move
        4->T
    End

    .MVENP (MVEN Post-move)
    Lbl MVENP

    .Now, handling special log behaviors (flipping, rolling, etc)
    !If T
        If C=1??C=2
            .Standing log to "lying" log
            0->G
            If {S+12}
                3->G
            ElseIf {S+13}
                4->G
            End

            If G
                MVENCHET(A,G)
                0->T
            End
        ElseIf C=4
            .Vertical log to standing log (if grounded)
            Select(U,
                IMOW({A+1},{A+2},{A+5},{S+12},{S+13})->G
            )->U
            0->T

            !If G
                MVENCHET(A,1)
                0->T
            End
        ElseIf C=3
            .Rolling log continues to roll (if grounded)
            Select(U,
                IMOW({A+1},{A+2},{A+5},{S+12},{S+13})->G
            )->U
            0->T

            !If G
                MVENPMTQ()
            End
        ElseIf C=5
            .Raft continues moving if on water
            Select(U,
                IMOW({A+1},{A+2},{A+5},{S+12},{S+13})->G
            )->U
            0->T

            !If G!=1??{S+14}e6=0
                MVENPMTQ()
            End
        End
    Else
        If C=2
            .Tree standing log, through any interaction, loses leaves
            1->{A}  .(could be done through MVENCHET, but no height change)
        ElseIf C=5?{S+23}!=2
            .If a raft stops, try moving stuff off of it if applicable
            .   (also, the not-equal-two check ensures that the raft actually
            .   sailed some distance before dropping its items)

            .Finding an entity we can try to move off
            Select(T,
            Select(U,
                GLMA({A+1},{A+2},{A+5},{S+12},{S+13})->G
            )->U
            )->T

            .Moving it off
            If G
                S->H
                -U*5+S->S
                Select(T,
                Select(U,
                    MVEN(G,signed{H+12},signed{H+13},{H+23}+1)
                )->I
                )->T
                I*5+S->S
                U+I->U

                .Restoring pointers to curr/target ent
                MVENRPTR()
            End
        End
    End

    .MVENR (MVEN Raft checking)
    Lbl MVENR

    .Finally, checking if we should combine this entity with the one below it
    .   to form a raft
    .The top and bottom entities must both be single logs (the bottom should
    .   not be standing), and neither should have any pending movements in
    .   the building queue.
    If {A}=1??{A}=3??{A}=4
        -U*5+S->S .(absorbing queue into stack)

        Select(T,
        Select(U,
            GHEB({A+1},{A+2},{A+5})->G
        )->U
        )->T

        If G?{G}=3??{G}=4
            .Both entities are single logs

            .Checking for queued movements
            If U
                For(H,0,U-1)
                    H*5+S->I
                    {I}={A+3}?{I+1}={A+4}
                        ->J
                    If J??{I}={G+3}?{I+1}={G+4}
                        .Found a queued movement for one log or the other
                        U*5+S->S
                        Goto MVENE
                    End
                End
            End

            .If no queued movements, combine our two entities into a raft!
            Select(T,
            Select(U,
                MKRF(G,A)
            )->U
            )->T

            .(no need to restore ent pointers since we're at MVENE)
        End

        U*5+S->S .(recovering stack)
    End

    .MVENE (MVEN End)
    Lbl MVENE
    {S}^r->A
    {S+2}^r->B
    {S+4}^r->C
    {S+6}^r->D
    {S+8}^r->E
    {S+10}^r->F
    S+24->S

    .If we put movements on stack, copy them just below stack pointer
    If U
        U*5->G
        S-G->H
        CPRV(H-24,H,G)
    End

    .(return)
    Return
}

Lbl MVENPMTQ {
    .MVEN Push Movement To Queue
    .Pushes the current movement in MVEN to the movement queue

    -U-1*5+S->G
    {A+3}^r->{G}^r
    {S+12}^r->{G+2}^r
    {S+23}+1->{G+4}
    U++

    Return
}

Lbl MVENRPTR {
    .MVEN Restore Pointers
    .Restores the pointers to the current and target entities

    {S+16}^r->G
    {G}^r+CE->A
    {S+18}^r->G
    {G}^r+CE->B

    Return
}

Lbl MVENCHET {
    .MVEN Change Entity Type
    .Moves any entities on top of the given entity if its height changes.
    .Will preserve queued movements, with count stored in U
    .r1: Pointer to entity whose type should change
    .r2: New entity type
    .Returns nothing

    .Allocating stack
    -U*5-2+S->S
    U->{S}^r

    .Getting change in height
    {r_1}->G
    nib{GDB1ENTH*2+G}^r->G      .old height
    nib{GDB1ENTH*2+r_2}^r->H    .new height
    H-G->I                      .height change

    If I
        .If there's a change in height, use MVER to shift all entities above
        Select(r_1,
        Select(r_2,
        Select(I,
            MVER(r_1,{r_1+1},{r_1+2},{r_1+5}+I)
        )->I
        )->r_2
        )->r_1

        .Then, move our original entity the opposite of the change in height
        {r_1+5}-I->{r_1+5}
    End

    .Finally, change the entity type
    r_2->{r_1}

    .Fixing stack
    {S}^r->U
    U*5+2+S->S

    Return
}
