.MExp Undo

Lbl LGUN {
    .Log Undo
    .Will take the six bytes below the stack pointer and log them in
    .  the current undo block

    .If we're not currently recording undos, exit early
    Return!If RU

    .Copying the bytes
    Copy(S-6,UP,6)

    .Moving the undo pointer
    INUP()

    .Incrementing number of undo units in this block
    NU++

    Return
}

Lbl STUN {
    .Start Undo

    .Setting undo pointer from current undo block header
    {UN}^r+UN->UP
    INUP()

    .Num units to undo = 0
    0->NU

    .Start recording undos
    1->RU

    Return
}

Lbl FIUN {
    .Finish undo

    .Log undo header
    UP-UN->{UN}^r
    0->{S-6}
    1->{S-5}
    NU->{S-4}
    LGUN()

    .Stop recording undos
    0->RU

    Return
}

Lbl UNDO {
    .Undo a single move

    .Allocating stack
    SSRG()

    .Putting pointer to block header in undo pointer
    {UN}^r+UN->UP

    .Making sure this block header has not been consumed
    Return!If {UP+1}

    .Iterating through undo units, making sure none have been overriden by
    .   block headers
    {UP+2}->A   .num units to undo
    For(B,1,A)
        DCUP()
        Return!If {UP}
    End

    .Returning pointer to current block header, marking it as consumed
    {UN}^r+UN->UP
    0->{UP+1}

    .Finally, iterating through each undo unit and undoing them
    For(B,1,A)
        .Moving undo pointer to next unit to undo
        DCUP()

        .Undoing this unit
        !If {UP}=4
            GCEP({UP+1},{UP+2})->H
        End
        {UP}->G
        If G=1
            .undo movement
            MVER(H,{UP+3},{UP+4},{UP+5})
        ElseIf G=2
            .undo type change
            CHET(H,{UP+3})
        ElseIf G=3
            .undo raft creation

            .changing raft back into a single log
            .(raft type is always 2 greater than respective log type)
            {H}-2->{H}

            .we would need to create the log atop the raft, but this will
            .  be undone by a subsequent undo entity deletion
        ElseIf G=4
            .undo entity deletion

            .first raise things above where this entity was
            GLEA({UP-5},{UP-4},{UP-1}-1)->G .pointer to lowest entity above
            {UP-6}->H                       .type of our entity
            nib{GDB1ENTH*2+H}^r->H          .height of our entity
            If G
                MVER(G,{UP-5},{UP-4},{UP-1}+H)
            End

            .then put the entity back
            S-8->S
            Copy(UP-6,S-8,6)    .most props from entity deletion 2 block
            {UP+2}^r->{S-2}^r   .extra bytes from entity deletion 1 block
            ADEN(S-8,{UP+1})    .island from entity deletion 1 block
            S+8->S

            .move an additional undo unit length, since this code consumes
            .  two units
            DCUP()
            B++
        ElseIf G=5
            .undo entity creation
            RMEN(H)
        ElseIf G=6
            .undo raft split
        End
    End

    .Setting new block header
    DCUP()
    UP-UN->{UN}^r

    .Restoring stack
    RSRG()

    Return
}

Lbl INUP {
    .Increment undo pointer

    UP+6->UP
    If UP-UN>=1802
        2+UN->UP
    End

    Return
}

Lbl DCUP {
    .Decrement undo pointer

    UP-6->UP
    If UP<UN
        1796+UN->UP
    End

    Return
}
