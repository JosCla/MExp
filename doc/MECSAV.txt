.Create Save

Lbl CSAV {
    .Creates a new savefile for MExp
    .Directly returns the creation status (0 good, higher bad)

    .Generates the entity map (MEEMAP.8xv)
    .Generates the current entities (MECENT.8xv)
    .Generates the current entity pointers (MEEPTR.8xv)
    .Generates the player data (MEPDAT.8xv)

    .Requires MEIMAP.8xv for size
    .Requires MEIDAT.8xv for entities

    .Saving variables to the stack
    S-8->S
    A->{S}^r
    B->{S+2}^r
    C->{S+4}^r
    D->{S+6}^r

    .Finding stats about this world file
    {Y_2}^r->A  .number of islands
    0->G        .number of entities
    For(H,1,A)
        {2*H+Y_2}^r->I
        .when i first wrote this code a while ago, i found that if you switch
        .   the terms in the sum, it acts as {I+Y_2}->G
        {I+Y_2}+G->G
    End
    {Y_1}->MW   .map width
    {Y_1+1}->MH .map height

    .Deleting save file if it exists
    DelVar Str1FEMAP
    DelVar Str1FCENT
    DelVar Str1FEPTR
    DelVar Str1FCSUM

    .Creating new save files

    .EMAP is the same size as IMAP
    GetCalc(Str1FEMAP,{Y_1-2}^r)->EM

    .CENT has 64B + (2B per island) + (12B per entity) + (12B player)
    GetCalc(Str1FCENT,G*6+A*2+76)->CE

    .EPTR has 2B num islands + 2B player entity pointer
        + (4B per island (pointer + ent count)) + (2B per entity pointer)
    GetCalc(Str1FEPTR,A*2+G*2+4)->EP

    .CSUM has 10B
    GetCalc(Str1FCSUM,10)->CS

    .Exit early if we couldn't allocate files
    !If EM?CE?EP?CS
        3->T .Bad exit code (could not allocate new files)
        Goto CSAVE
    End

    .Saving basic properties to files
    MW->{EM}                .EMAP map width
    MH->{EM+1}              .EMAP map height
    {Y_1-2}^r-1->H
    For(G,2,H)              .EMAP zeroing out
        0->{EM+G}
    End
    A->{CE}^r               .CENT num islands
    A*2+16->{A*2+2+CE}^r    .CENT first empty pointer
    A->{EP}^r               .EPTR num islands
    A*2+4->C                .EPTR first island pointer

    .Putting the checksum into CSUM
    CCSM()
    Copy(S-10,CS,10)

    .Putting a dummy player entity in the world, for island resetting
    .NOTE: all C in the following statements actually represent A*2+4
    .   but they're just C since C already holds that value
    For(G,0,11)
        0->{C+G+CE} .(CENT)
    End
    C->{C-2+EP}^r   .(EPTR)
    1->{2+EM}       .(EMAP)

    .Iterating through each island
    1->D    .first island
    For(B,1,A)
        .Getting number of entities on this island
        {2*B+Y_2}^r->G
        {G+Y_2}->H

        .Add pointer to first entity in CENT
        .NOTE: all C in the following statements actually represent A*2+4
        .   but they're just C since C already holds that value
        B=1?C,0
        ->{B*2+CE}^r

        .Add pointer to island data in EPTR, and num ents on island
        C->{B*2+EP}^r
        H->{C+EP}^r
        C+2->C

        .Iterate entities, set their EPTR to zero
        For(I,1,H)
            0->{C+EP}^r
            C+2->C
        End

        .Check if this is the first island
        If {G+4+Y_2}
            B->D
        End

        .Reset the island
        RSTI(B)
    End

    .Resetting the first island to put the player there
    RSTI(D)

    .Good exit code
    0->T

    .End
    Lbl CSAVE

    .Recover the stack
    {S}^r->A
    {S+2}^r->B
    {S+4}^r->C
    {S+6}^r->D
    S+8->S

    .(return)
    TReturn
}

Lbl CCSM {
    .Calculate checksum
    .Places the checksum in the 10 bytes below the stack pointer

    .Getting file sizes
    {Y_1-2}^r->G    .map size
    {Y_2-2}^r->H    .idat size
    {Y_5-2}^r->I    .strs size

    .Putting checksums below stack pointer
    {Y_1+G}^r->{S-10}^r
    {Y_2+H}^r->{S-8}^r
    {Y_3+G}^r->{S-6}^r
    {Y_4+G}^r->{S-4}^r
    {Y_5+I}^r->{S-2}^r

    Return
}
