Lbl MVEF {
    .Fully moves an entity
    .  (Temporary function for making sure this all works well)
    .r1: Entity pointer
    .r2: DispX
    .r3: DispY

    .Allocating stack
    S-2->S
    A->{S}^r

    .Moving the original entity
    MVEN()

    .A is now the number of actions in the previous queue frame
    0->A

    .Performing successive movements
    While U
        .Moving next queue frame into the stack
        If A
            A*5->G
            U*5->H
            -H+S->I
            CPRV(I,I+G,H)
        End
        A-U*5+S->S

        .Storing the previous number of frame actions in A
        U->A

        .Displaying what just happened
        .NOTE: The double DispGraph maintains parity between draws.
        .  Without it, the screen flashes with each move, which may
        .  cause dangerous eye-strain.
        DSCR(0,0,1)
        DispGraph^r
        DispGraph^r

        .Advancing a single tick
        MVET(A)
    End

    .Restoring stack
    A*5+S->S
    {S}^r->A
    S+2->S
}

Lbl MVET {
    .Moves entities through a single tick
    .r1: Number of actions to execute in the current queue frame
    .  The movements should be executed from high to low memory addresses
    .U: Number of movements pushed to stack
    .  New movements will be pushed below stack pointer, to be executed from
    .  high to low memory addresses
    .  (put in U instead of T to be consistent with MVEN)

    .Allocating stack
    S-10->S
    A->{S}^r
    B->{S+2}^r
    C->{S+4}^r
    D->{S+6}^r
    E->{S+8}^r

    .Storing the base pointer of actions to execute in D
    S+10->D

    .Storing num actions to execute in A
    r_1->A

    .Executing all actions (storing total actions pushed in C)
    0->C
    For(B,1,A)
        .Getting pointer to current action
        A-B*5+D->E

        .Getting pointer to entity in question
        GCEP({E},{E+1})->G

        .Performing movement
        MVEN(G,signed{E+2},signed{E+3})
        C+U->C
        -U*5+S->S
    End

    .(Putting number of movements added into U)
    C->U

    .Recovering stack
    D-10->S
    {S}^r->A
    {S+2}^r->B
    {S+4}^r->C
    {S+6}^r->D
    {S+8}^r->E
    S+10->S

    .Moving newly added actions directly underneath stack pointer
    U*5->G
    S-G->H
    CPRV(H-10,H,G)
}

Lbl MVEN {
    .Moves an entity
    .r1: pointer to entity to move
    .r2: dispX
    .r3: dispY
    .T: movement state
        0: success
        1: out of bounds
        2: blocked
        3: couldn't move (player trying to move onto water, off sideways log)
    .U: number of movements pushed to stack

    .Storing to stack
    S-21->S
    r_2->{S}^r
    r_3->{S+2}^r
    A->{S+4}^r
    B->{S+6}^r
    C->{S+8}^r
    D->{S+10}^r
    E->{S+12}^r
    F->{S+14}^r
    .(plus 2 bytes on end to store target position)
    .(plus another byte on end to store target height)
    .(plus another 2 bytes on end to store property bytes)

    .Keeping entity pointer in A
    r_1->A

    .Finding target position for entity
    {A+1}+r_2->D
    {A+2}+r_3->E

    .Finding entity collision type
    GECT({A},r_2,r_3)->F

    .Make sure it's in-bounds
    .(due to unsigned comparison, this implicitly makes sure it's non-negative)
    !If D<MW?E<MH
        1->T
        0->U
        Goto MVENE
    End

    .Putting property bytes for current position and target position on stack
    GPBA({A+1},{A+2})->{S+19}
    GPBA(D,E)->{S+20}

    .If we're trying to move into an impenetrable rock, we're blocked
    If {S+20}e4
        2->T
        0->U
        Goto MVENE
    End

    .Putting target position onto the stack
    D->{S+16}
    E->{S+17}

    .Finding the relative height of the target space
    GHAT(D,E)+1->B
    B-{A+5}->H

    If nib{GDB1MEAH*2+F}>=>=H
        .We can move to this space! (for now, just forcing the movement)

        .Checking for entities on this spot
        If GSEH({S+16},{S+17})->C
            .Finding the highest entity at/below the player (push target)
            max({A+5},B)->K
            For(I,1,C)
                {-C+I-1*2+S}^r->D
            EndIf {D+5}<=K
            I=C->E .(E is true if our target is the bottom entity)

            .Getting interaction type between the two entities
            GECT({D},{S}^r,{S+2}^r)->L
            nib{GDB1ENTH*2+L}+{D+5}->M
            If M>K
                .Above
                nib{F*4+GDB1EITA*2+L}->N
            Else
                .Below
                nib{F*4+GDB1EITB*2+L}->N
            End

            .Handling interaction type
            !If N
                .Blocked
                2->T
                0->U
            ElseIf N=1
                .Move
                MVER(A,{S+16},{S+17},M)
                0->T
                0->U
            ElseIf N=2
                .Push (but also blocked)
                MVEN(D,{S}^r,{S+2}^r)
                2->T
            ElseIf N=3
                .Push then move
                {D+5}->{S+18}
                MVEN(D,{S}^r,{S+2}^r)
                !If T
                    If E
                        S->G
                        -U*5-4+S->S
                        T->{S}^r
                        U->{S+2}^r
                        MVER(A,{G+16},{G+17},{G+18})
                        {S}^r->T
                        {S+2}^r->U
                        U*5+4+S->S
                        .TODO: will have to re-fetch A after adding raft combo
                    Else
                        -U-1*5+S->G
                        {A+3}^r->{G}^r
                        {S}^r->{G+2}
                        {S+2}^r->{G+3}
                        0->{G+4}
                        U++
                        2->T
                        .TODO: will have to re-fetch A after adding raft combo
                    End
                Else
                    .(blocked)
                    2->T
                End
            ElseIf N=4
                .Double move
                MVER(A,{S+16},{S+17},M)
                .TODO: push another movement to mvmt queue
                0->T
                0->U .(will be 1)
            End
        Else
            .If no entities, we can just move here
            MVER(A,{S+16},{S+17},B)

            0->T .(successful movement!)
            0->U
        End

        .Goto MVENE
    Else
        .This space is too high to move to; we've been blocked!
        2->T
        0->U
        .Goto MVENE
    End

    .Now, handling special log behaviors (flipping, rolling, etc)
    !If T
        If F=1??F=2
            .Standing log to "lying" log
            If {S}^r
                3->{A}
            ElseIf {S+2}^r
                4->{A}
            End
        ElseIf F=4
            .Vertical log to standing log
            1->{A}
        ElseIf F=3
            .Rolling log continues to roll
            -U-1*5+S->G
            {A+3}^r->{G}^r
            {S}^r->{G+2}
            {S+2}^r->{G+3}
            0->{G+4}
            U++
        End
    Else
        If F=2
            .Tree standing log, through any interaction, loses leaves
            1->{A}
        End
    End

    .MVEN end
    Lbl MVENE
    {S+4}^r->A
    {S+6}^r->B
    {S+8}^r->C
    {S+10}^r->D
    {S+12}^r->E
    {S+14}^r->F
    S+21->S

    .If we put movements on stack, copy them just below stack pointer
    If U
        U*5->G
        S-G->H
        CPRV(H-21,H,G)
    End

    .(return)
    Return
}

Lbl MVER {
    .Move entity (raw)
    .Just moves an entity without any logic or collision checking
    .Will not change the entity's position in CENT
    .r1: Pointer to entity
    .r2-r4: Target X,Y,Z

    .Storing arguments and vars to stack
    .Also allocating a little space to store the entity's prev. position
    S-18->S
    r_1->{S}^r
    r_2->{S+2}
    r_3->{S+3}
    A->{S+4}^r
    B->{S+6}^r
    C->{S+8}^r
    D->{S+10}^r
    E->{S+12}^r
    F->{S+14}^r

    .Storing entity start position on stack
    {r_1+1}->{S+16}
    {r_1+2}->{S+17}

    .Finding height diff from old to new position
    r_4-{r_1+5}->B

    .Finding current EMAP and target position EMAP value
    GEIA({S+16},{S+17})->E
    GIAT({S+2},{S+3})        .First check if there's an island at target
        ??GEIA({S+2},{S+3})  .Then if there's already entity at target
        ??E                  .Default to current EMAP val
    ->F                      .(Store the result to F)

    .Getting all entities at the current position, absorbing them into stack
    GSEH({S+16},{S+17})->A
    -A*2+S->S

    .Moving our entity and all entities above to new position
    For(C,0,A-1)
        .Getting pointer to current entity in stack
        C*2+S->G
        {G}^r->D

        .Moving the entity's position in CENT
        A*2+S->H
        {H+2}->{D+1}
        {H+3}->{D+2}
        {D+5}+B->{D+5}

        .Moving entity from one island to another if needed
        E!=F?CHEI(D,E,F)

    .(Break from the loop if we just moved our original entity!)
    EndIf {A*2+S}^r=D

    .Dropping entities at previous position from stack
    A*2+S->S

    .Clearing prev. EMAP pos if we moved everything
    If A-1<=C
        {S+16}->G
        {S+17}->H
        0->{H*MW+G+2+EM}
    End

    .Setting the new EMAP pos regardless
    {S+2}->G
    {S+3}->H
    F->{H*MW+G+2+EM}
    
    .Restoring stack and variables
    {S+4}^r->A
    {S+6}^r->B
    {S+8}^r->C
    {S+10}^r->D
    {S+12}^r->E
    {S+14}^r->F
    S+18->S

    .(return)
    Return
}

Lbl GECT {
    .Get entity collision type
    .r1: entity type
    .r2: dispX
    .r3: dispY

    If r_1<3
        .Player, standing log, or standing tree
        r_1Return
    ElseIf r_1=5??r_1=6
        .Raft
        5Return
    ElseIf r_1>6
        .Immobile (snowman or sign)
        6Return
    ElseIf r_2
        .Laid down logs (horizontal movement)
        If r_1=3
            4Return
        Else
            3Return
        End
    ElseIf r_3
        .Laid down logs (vertical movement)
        r_1Return
    End

    .Indeterminate type (laid down log without movement)
    -1Return
}

Lbl CHEI {
    .Change entity island
    .r1: Pointer to entity
    .r2: Entity's current island
    .r3: Entity's new island

    .First "removing" our entity from its current linked list
    {r_1+8}^r->G  .prev pointer
    {r_1+10}^r->H .next pointer

    .Correcting the next entity's previous entity pointer
    If H
        G->{H+8+CE}^r
    End

    .Correcting the previous entity (or list head) next entity pointer
    If G
        H->{G+10+CE}^r
    Else
        H->{r_2*2+CE}^r
    End

    .Now, "inserting" our entity at the start of the target linked list
    {r_3*2+CE}^r->G .entity at head of target linked list

    .Correcting head of linked list, and our previous entity pointer
    r_1-CE->{r_3*2+CE}^r
    0->{r_1+8}^r

    .Correcting head entity's previous pointer, and our next pointer
    If G
        r_1-CE->{G+8+CE}^r
    End
    G->{r_1+10}^r

    Return
}

Lbl GCEP {
    .Get current entities pointer
    .r1-r2: entity id (island, ent num)
    .Directly returns the pointer in curr. entities

    {GEPP()}^r+CEReturn
}

Lbl GEPP {
    .Get entity pointers pointer
    .Effectively, this will find the location of the place in EPTR that
    .  points to this entity in CENT
    .r1-r2: entity id (island, ent num)
    .Directly returns the pointer to the pointer in EPTR

    If r_1
        .Non-player
        {r_1*2+EP}^r->G
        r_2*2+G+EPReturn
    End

    .Player
    {EP}^r->G
    G*2+2+EPReturn
}

Lbl GENI {
    .Get entity island
    .r1-r2: entity id (island, ent num)
    .Directly returns the entity island number

    .Finding the entity's position
    GENP(r_1,r_2)

    .Returning the island at that position
    GEIA(T,U)Return
}
    
Lbl GENP {
    .Get entity position
    .r1-r2: entity id (island, ent num)
    .T: posX
    .U: posY

    .Using entity pointer to find where the entity is
    GCEP()->G
    {G+1}->T
    {G+2}->U

    .(return)
    Return
}    

Lbl GSEH {
    .Get sorted entity list by height
    .r1-r2: posX, posY
    .Directly returns the length of the entity list
    .Will place the sorted list (pointers to CENT) below stack pointer S
    .  (the list has lower height at higher addresses, higher height at lower)

    .First finding the entity island at this position
    .  (arguments are already in the right spots)
    GEIA()->G

    .(if no entity here, just return an empty list)
    Return!If G

    .Traversing the island's linked list to find entities at this position
    0->T
    {G*2+CE}^r->H
    While H
        H+CE->I

        .Checking if the entity is at the right spot
        If {I+1}=r_1?{I+2}=r_2
            .If the entity is at the right spot, we can insert it!
            If T
                .Find first element whose height is less
                T-1->J
                For(K,0,J)
                    {-K-1*2+S}^r->L
                EndIf {I+5}<{L+5}

                .Shift over greater elements
                T-K->J .(num elements to shift)
                If J
                    Copy(-T*2+S,-T-1*2+S,J*2)
                End

                .Insert at our desired position
                I->{-K-1*2+S}^r
            Else
                .Empty list, just insert at the first position
                I->{S-2}^r
            End

            .Incrementing list length
            T++
        End

        .Going to next list element
        {I+10}^r->H
    End
   
    .Finally, returning our list length
    TReturn
}
