.MEENTS

Lbl MVEN {
    .Moves an entity
    .r1: pointer to entity to move
    .r2: dispX
    .r3: dispY
    .T: movement state
        0: success
        1: out of bounds
        2: blocked
        3: couldn't move (player trying to move onto water, off sideways log)
    .U: number of movements pushed to stack

    .Storing to stack
    S-16->S
    r_2->{S}^r
    r_3->{S+2}^r
    A->{S+4}^r
    B->{S+6}^r
    C->{S+8}^r
    D->{S+10}^r
    E->{S+12}^r
    F->{S+14}^r

    .Keeping entity pointer in A
    r_1->A

    .Finding target position for entity
    {A+1}+r_2->D
    {A+2}+r_3->E

    .Make sure it's in-bounds
    .(due to unsigned comparison, this implicitly makes sure it's non-negative)
    !If D<MW?E<MH
        1->T
        0->U
        Goto MVENE
    End

    .Finding entity collision type
    sub(GECT,{A},r_2,r_3)->F

    .Finding the relative height of the target space
    sub(GHAT,D,E)+1->B
    B-{A+5}->H

    If {GDB1MEAH+F}>=>=H
        .We can move to this space! (for now, just forcing the movement)

        .Checking for entities on this spot
        If sub(GSEH,D,E)->C
            .Finding the lowest entity we can push
            max({A+5},B)->K
            For(I,0,C)
                {-I-1*2+S}^r->J
            EndIf {J+5}<=K

            .Trying to move it if it's at the right level
            If {J+5}=K
                sub(MVEN,J,{S}^r,{S+2}^r)
            Else
                0->T
            End

            .If it moved successfully, we can then move
            !If T
                sub(MVER,A,D,E,B)

                0->T (successful movement!)
                0->U
            Else
                2->T (blocked)
                0->U
            End
        Else
            .If no entities, we can just move here
            sub(MVER,A,D,E,B)

            0->T .(successful movement!)
            0->U
        End

        .Goto MVENE
    Else
        .This space is too high to move to; we've been blocked!
        2->T
        0->U
        .Goto MVENE
    End

    .MVEN end
    Lbl MVENE
    {S+4}^r->A
    {S+6}^r->B
    {S+8}^r->C
    {S+10}^r->D
    {S+12}^r->E
    {S+14}^r->F
    S+16->S

    .(return)
    Return
    
    if (too high) 
        .for most, it's one tile above. for player, two above, etc
        .then we can't move there
    else
        .get the highest entity
        .also note that if we're the player on a sideways log or raft on water,
            we need to use a different table to get interaction types
        if (none)
            .should be able to go there
            .(unless we're a player on a sideways log going onto equal height)
        else
            if (below)
                .handle below interaction
            else
                .find the lowest entity we can interact with
                    (don't forget that a standing log can be below foot level
                    but interactable)
                .handle push interaction with that entity

    .in any case, if we can move, then make a movement and then "update"
        (gives a chance to combine to rafts, let roll logs keep going, etc)
}

Lbl MVER {
    .Move entity (raw)
    .Just moves an entity without any logic or collision checking
    .r1: Pointer to entity
    .r2-r4: Target X,Y,Z

    .Storing arguments and vars to stack
    .Also allocating a little space to store the entity's prev. position
    S-18->S
    r_1->{S}^r
    r_2->{S+2}
    r_3->{S+3}
    A->{S+4}^r
    B->{S+6}^r
    C->{S+8}^r
    D->{S+10}^r
    E->{S+12}^r
    F->{S+14}^r

    .Storing entity start position on stack
    {r_1+1}->{S+16}
    {r_1+2}->{S+17}

    .Finding height diff from old to new position
    r_4-{r_1+5}->B

    .Finding current EMAP and target position EMAP value
    sub(GEIA,{S+16},{S+17})->E
    sub(GIAT,{S+2},{S+3})        .First check if there's an island at target
        ??sub(GEIA,{S+2},{S+3})  .Then if there's already entity at target
        ??E                      .Default to current EMAP val
    ->F                          .(Store the result to F)

    .Getting all entities at the current position, absorbing them into stack
    sub(GSEH,{S+16},{S+17})->A
    -A*2+S->S

    .Moving our entity and all entities above to new position
    For(C,0,A-1)
        .Getting pointer to current entity in stack
        C*2+S->G
        {G}^r->D

        .Finding the pointer to this entity in EPOS
        sub(GEPP,{D+3},{D+4})->G

        .Moving the entity's position in CENT and EPOS
        A*2+S->H
        {H+2}->{D+1}
        {H+2}->{G}
        {H+3}->{D+2}
        {H+3}->{G+1}
        {D+5}+B->{D+5}

        .Moving entity from one island to another if needed
        E!=F?sub(CHEI,D,E,F)

    .(Break from the loop if we just moved our original entity!)
    EndIf {A*2+S}^r=D

    .Dropping entities at previous position from stack
    A*2+S->S

    .Clearing prev. EMAP pos if we moved everything
    If A-1<=C
        {S+16}->G
        {S+17}->H
        0->{H*MW+G+2+EM}
    End

    .Setting the new EMAP pos regardless
    {S+2}->G
    {S+3}->H
    F->{H*MW+G+2+EM}
    
    .Restoring stack and variables
    {S+4}^r->A
    {S+6}^r->B
    {S+8}^r->C
    {S+10}^r->D
    {S+12}^r->E
    {S+14}^r->F
    S+18->S

    .(return)
    Return

    .TODO:
    .Special case for player entity! (Don't update EPOS, etc)
    .Should find target EMAP value by following logic:
    .  If new space is an island or already has entities on it
    .    Then keep that as EMAP value, and transfer our entity if needed
    .  Else If new space is unoccupied and not an island
    .    Then keep our previous EMAP value
    .And, if our target EMAP value is different, transfer over all moved
    .  entities to the new island!
}

Lbl GECT {
    .Get entity collision type
    .r1: entity type
    .r2: dispX
    .r3: dispY

    If r_1<3
        .Player, standing log, or standing tree
        r_1Return
    ElseIf r_1=5??r_1=6
        .Raft
        5Return
    ElseIf r_1>6
        .Immobile (snowman or sign)
        6Return
    ElseIf r_2
        .Laid down logs (horizontal movement)
        If r_1=3
            4Return
        Else
            3Return
        End
    ElseIf r_3
        .Laid down logs (vertical movement)
        r_1Return
    End

    .Indeterminate type (laid down log without movement)
    -1Return
}

Lbl CHEI {
    .Change entity island
    .r1: Pointer to entity
    .r2: Entity's current island
    .r3: Entity's new island

    .First "removing" our entity from its current linked list
    {r_1+8}^r->G  .prev pointer
    {r_1+10}^r->H .next pointer

    .Correcting the next entity's previous entity pointer
    If H
        G->{H+8+CE}^r
    End

    .Correcting the previous entity (or list head) next entity pointer
    If G
        H->{G+10+CE}^r
    Else
        H->{r_2*2+CE}^r
    End

    .Now, "inserting" our entity at the start of the target linked list
    {r_3*2+CE}^r->G .entity at head of target linked list

    .Correcting head of linked list, and our previous entity pointer
    r_1-CE->{r_3*2+CE}^r
    0->{r_1+8}^r

    .Correcting head entity's previous pointer, and our next pointer
    If G
        r_1-CE->{G+8+CE}^r
    End
    G->{r_1+10}^r

    Return
}

Lbl GCEP {
    .Get current entities pointer
    .r1-r2: entity id (island, ent num)
    .Directly returns the pointer in current entities

    .Storing args to stack
    S-4->S
    r_1->{S}^r
    r_2->{S+2}^r

    .First getting the entity island
    sub(GENI,r_1,r_2)->G

    .Recalling args
    {S}^r->r_1
    {S+2}^r->r_2
    S+4->S

    .Traversing the island's linked list to find the entity in question
    {G*2+CE}^r->H
    While H
        .Return our entity if we've found it
        If ({H+3+CE}=r_1) and ({H+4+CE}=r_2)
            H+CEReturn
        End

        .If we haven't found it, go to next list element
        {H+10+CE}^r->H
    End

    .Returning 0 if we found nothing
    0Return
}

Lbl GENI {
    .Get entity island
    .r1-r2: entity id (island, ent num)
    .Directly returns the entity island number

    .Finding the entity's position
    sub(GENP,r_1,r_2)

    .Returning the island at that position
    sub(GEIA,T,U)Return
}
    
Lbl GENP {
    .Get entity position
    .r1-r2: entity id (island, ent num)
    .T: posX
    .U: posY

    .Using EPOS to find where the entity is
    sub(GEPP)->G
    {G}->T
    {G+1}->U

    .(return)
    Return
}    

Lbl GEPP {
    .Get entity pos pointer
    .r1-r2: entity id (island, ent num)
    .Directly returns pointer
    
    {r_1*2+EP}^r->G
    r_2*2+G+EPReturn
}

Lbl GSEH {
    .Get sorted entity list by height
    .r1-r2: posX, posY
    .Directly returns the length of the entity list
    .Will place the sorted list (pointers to CENT) below stack pointer S
    .  (the list has lower height at higher addresses, higher height at lower)

    .First finding the entity island at this position
    sub(GEIA,r_1,r_2)->G

    .(if no entity here, just return an empty list)
    Return!If G

    .Firstly, if the player is here, insert them into the linked list
    If {^PD+1}=r_1?{^PD+2}=r_2
        ^PD->{S-2}^r
        1->T .(list starts with 1 element)
    Else
        0->T .(list starts with 0 elements)
    End

    .Traversing the island's linked list to find entities at this position
    {G*2+CE}^r->H
    While H
        H+CE->I

        .Checking if the entity is at the right spot
        If {I+1}=r_1?{I+2}=r_2
            .If the entity is at the right spot, we can insert it!
            If T
                .Find first element whose height is less
                T-1->J
                For(K,0,J)
                    {-K-1*2+S}^r->L
                EndIf {I+5}<{L+5}

                .Shift over greater elements
                T-K->J .(num elements to shift)
                If J
                    Copy(-T*2+S,-T-1*2+S,J*2)
                End

                .Insert at our desired position
                I->{-K-1*2+S}^r
            Else
                .Empty list, just insert at the first position
                I->{S-2}^r
            End

            .Incrementing list length
            T++
        End

        .Going to next list element
        {I+10}^r->H
    End
   
    .Finally, returning our list length
    TReturn
}

    .handle our interaction type
    .0: just stop
    .1: just move
    .2: just push
    .3: try to push out of way, then try to move in
    .4: push and raft away
    .5: raft away

    if (no entity)
        .We can move there if <= height or 1 higher if player/upright log
        .But also player can't move there if it's too much lower or water
    else
        .Find the highest entity on our target tile (could combine with above if-statement)
        if (below)
            .Check interaction per entity type
            (if we are upright pushing onto sideways log, try to push out of way before moving onto it anyways)
        else
            .Same, but pushing into lowest entity we can push
    (perhaps first clause of above if-stmt for no ents should, like the second clause, produce one of the common interaction set's things)
    (and since it applies fairly universally, maybe we wrap the whole thing in the height checking?)

    .Now, we handle our interaction type
        (if no move, just stop. if push -> move, do that.)
        (if we move, also move all stuff above)
            (and if we move onto new island, change island ownership for us and all entities above)
        (and either way, track whether we were able to successfully move)
    .And, "update" our entity
        (flip logs, combine to rafts, etc)

